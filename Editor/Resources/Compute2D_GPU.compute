// Compute2D_GPU.compute
// GPU描画 + ヒットテスト用 ComputeShader
// v2.4 - 頂点・線分・面ヒットテストに深度出力追加

#pragma kernel ClearBuffers
#pragma kernel ComputeScreenPositions
#pragma kernel ComputeFaceVisibility
#pragma kernel ComputeLineVisibility
#pragma kernel ComputeVertexHitTest
#pragma kernel ComputeLineHitTest
#pragma kernel ComputeFaceHitTest

// ================================================================
// 構造体定義
// ================================================================

struct LineSegment { int v1; int v2; int faceIndex; int lineType; };

// ================================================================
// バッファ
// ================================================================

// 入力バッファ
StructuredBuffer<float3> _PositionBuffer;
StructuredBuffer<LineSegment> _LineBuffer;
ByteAddressBuffer _FaceVertexIndexBuffer;
ByteAddressBuffer _FaceVertexOffsetBuffer;
ByteAddressBuffer _FaceVertexCountBuffer;

// 出力バッファ（描画用）
RWStructuredBuffer<float4> _ScreenPositionBuffer;
RWStructuredBuffer<float> _VertexVisibilityBuffer;
RWStructuredBuffer<float> _FaceVisibilityBuffer;
RWStructuredBuffer<float> _LineVisibilityBuffer;

// ヒットテスト用出力バッファ
RWStructuredBuffer<float> _VertexHitDistanceBuffer;
RWStructuredBuffer<float> _VertexHitDepthBuffer;   // 頂点の深度
RWStructuredBuffer<float> _LineHitDistanceBuffer;
RWStructuredBuffer<float> _LineHitDepthBuffer;     // 線分の深度（補間）
RWStructuredBuffer<float> _FaceHitBuffer;  // 0.0 or 1.0 (float型に変更)
RWStructuredBuffer<float> _FaceHitDepthBuffer;  // 面の深度（Z値）

// ================================================================
// パラメータ
// ================================================================

float4x4 _MATRIX_MVP;
float4x4 _ModelMatrix;   // モデル行列（ミラー変換等に使用、単位行列がデフォルト）
float4 _ScreenParams;    // windowSize.x, windowSize.y, 0, 0
float4 _PreviewRect;     // x, y, width, height
uint _VertexCount;
uint _FaceCount;
uint _LineCount;
uint _IsMirrored;        // ミラー変換時は1（面の向き判定を反転）

// 統合バッファ用オフセット（Phase GPU-Unified）
uint _VertexOffset;      // 統合バッファ内の頂点開始位置
uint _EdgeOffset;        // 統合バッファ内のエッジ開始位置
uint _FaceOffset;        // 統合バッファ内の面開始位置

// MeshObject選択状態（Phase GPU-Unified）
uint _IsMeshObjectSelected;  // 0=非選択MeshObject, 1=選択MeshObject

// ヒットテスト用パラメータ
float2 _MousePosition;   // マウス座標（adjustedRect座標系）

// ================================================================
// 描画用カーネル（既存）
// ================================================================

[numthreads(64, 1, 1)]
void ClearBuffers(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    // オフセットを適用してクリア
    if (index < _VertexCount) { 
        uint globalIdx = _VertexOffset + index;
        _VertexVisibilityBuffer[globalIdx] = 0.0; 
        _ScreenPositionBuffer[globalIdx] = float4(-10000, -10000, 0, 0); 
    }
    if (index < _FaceCount) { 
        uint globalIdx = _FaceOffset + index;
        _FaceVisibilityBuffer[globalIdx] = 0.0; 
    }
    if (index < _LineCount) { 
        uint globalIdx = _EdgeOffset + index;
        _LineVisibilityBuffer[globalIdx] = 0.0; 
    }
}

[numthreads(64, 1, 1)]
void ComputeScreenPositions(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= _VertexCount) return;
    
    // オフセットを適用して統合バッファから読み取り
    uint globalIdx = _VertexOffset + index;
    float3 localPos = _PositionBuffer[globalIdx];
    
    // ModelMatrixで変換（トランスフォーム表示、ミラー等に使用）
    // 単位行列の場合は元の位置のまま
    float3 worldPos = mul(_ModelMatrix, float4(localPos, 1.0)).xyz;
    float4 clipPos = mul(_MATRIX_MVP, float4(worldPos, 1.0));
    if (clipPos.w > 0.0001)
    {
        float2 ndc = clipPos.xy / clipPos.w;
        // previewRect内のローカル座標 + previewRectのオフセット = ウィンドウ座標
        float screenX = _PreviewRect.x + (ndc.x * 0.5 + 0.5) * _PreviewRect.z;
        float screenY = _PreviewRect.y + (1.0 - (ndc.y * 0.5 + 0.5)) * _PreviewRect.w;
        _ScreenPositionBuffer[globalIdx] = float4(screenX, screenY, clipPos.z / clipPos.w, 1.0);
    }
    else { _ScreenPositionBuffer[globalIdx] = float4(-10000, -10000, -10000, 0.0); }
}

bool IsClockwise(float2 vertices[16], int numVertices)
{
    float signedArea = 0;
    for (int i = 0; i < numVertices; i++)
    {
        int next = (i + 1) % numVertices;
        signedArea += (vertices[next].x - vertices[i].x) * (vertices[next].y + vertices[i].y);
    }
    // GUI座標系はY軸下向きなので符号を反転
    return signedArea < 0;
}

[numthreads(64, 1, 1)]
void ComputeFaceVisibility(uint3 id : SV_DispatchThreadID)
{
    uint faceIndex = id.x;
    if (faceIndex >= _FaceCount) return;
    
    // オフセットを適用してグローバルインデックスを取得
    uint globalFaceIdx = _FaceOffset + faceIndex;
    
    int vertexCount = asint(_FaceVertexCountBuffer.Load(globalFaceIdx * 4));
    int offset = asint(_FaceVertexOffsetBuffer.Load(globalFaceIdx * 4));
    if (vertexCount <= 2)
    {
        _FaceVisibilityBuffer[globalFaceIdx] = 1.0;
        for (int j = 0; j < vertexCount; j++)
        {
            int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + j) * 4));
            // vIdxは統合バッファ構築時に既にグローバル化されている
            _VertexVisibilityBuffer[vIdx] = 1.0;
        }
        return;
    }
    float2 screenVerts[16];
    bool allValid = true;
    for (int i = 0; i < vertexCount && i < 16; i++)
    {
        int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + i) * 4));
        float4 screenPos = _ScreenPositionBuffer[vIdx];
        if (screenPos.w < 0.5) { allValid = false; break; }
        screenVerts[i] = screenPos.xy;
    }
    if (!allValid) { _FaceVisibilityBuffer[globalFaceIdx] = 0.0; return; }
    bool isFrontFacing = IsClockwise(screenVerts, vertexCount);
    // ミラー変換時は面の向きが反転するので判定も反転
    if (_IsMirrored != 0) isFrontFacing = !isFrontFacing;
    _FaceVisibilityBuffer[globalFaceIdx] = isFrontFacing ? 1.0 : 0.0;
    if (isFrontFacing)
    {
        for (int k = 0; k < vertexCount; k++)
        {
            int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + k) * 4));
            _VertexVisibilityBuffer[vIdx] = 1.0;
        }
    }
}

[numthreads(64, 1, 1)]
void ComputeLineVisibility(uint3 id : SV_DispatchThreadID)
{
    uint lineIndex = id.x;
    if (lineIndex >= _LineCount) return;
    
    // オフセットを適用してグローバルインデックスを取得
    uint globalLineIdx = _EdgeOffset + lineIndex;
    uint globalFaceOffset = _FaceOffset;
    
    LineSegment seg = _LineBuffer[globalLineIdx];
    if (seg.lineType == 1) { _LineVisibilityBuffer[globalLineIdx] = 1.0; return; }
    
    // faceIndexもグローバル化されている（統合バッファ構築時）
    _LineVisibilityBuffer[globalLineIdx] = _FaceVisibilityBuffer[seg.faceIndex];
}

// ================================================================
// ヒットテスト用カーネル
// ================================================================

/// <summary>
/// 頂点ヒットテスト：各頂点とマウス座標の距離を計算
/// 深度（Z値）も出力
/// 
/// 【注意】_MousePosition は adjustedRect 座標系で渡すこと
/// 呼び出し側で以下の変換が必要：
///   float ratioY = mousePos.y / rect.height;
///   float adjustedMouseY = tabHeight + ratioY * (rect.height - tabHeight);
/// </summary>
[numthreads(64, 1, 1)]
void ComputeVertexHitTest(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= _VertexCount) return;
    
    // オフセットを適用
    uint globalIdx = _VertexOffset + index;
    
    float4 screenPos = _ScreenPositionBuffer[globalIdx];
    float visibility = _VertexVisibilityBuffer[globalIdx];
    
    // 不可視の頂点は無限大距離・深度
    if (visibility < 0.5 || screenPos.w < 0.5)
    {
        _VertexHitDistanceBuffer[globalIdx] = 1e10;
        _VertexHitDepthBuffer[globalIdx] = 1e10;
        return;
    }
    
    // マウスとの距離を計算
    float2 diff = screenPos.xy - _MousePosition;
    _VertexHitDistanceBuffer[globalIdx] = length(diff);
    
    // 深度を出力
    _VertexHitDepthBuffer[globalIdx] = screenPos.z;
}

/// <summary>
/// 線分ヒットテスト：各線分とマウス座標の最短距離を計算
/// 深度（マウス最近接点のZ値を補間）も出力
/// 
/// 【注意】_MousePosition は adjustedRect 座標系で渡すこと
/// </summary>
[numthreads(64, 1, 1)]
void ComputeLineHitTest(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= _LineCount) return;
    
    // オフセットを適用
    uint globalLineIdx = _EdgeOffset + index;
    
    LineSegment seg = _LineBuffer[globalLineIdx];
    float visibility = _LineVisibilityBuffer[globalLineIdx];
    
    // 不可視の線分は無限大距離・深度
    if (visibility < 0.5)
    {
        _LineHitDistanceBuffer[globalLineIdx] = 1e10;
        _LineHitDepthBuffer[globalLineIdx] = 1e10;
        return;
    }
    
    // seg.v1, seg.v2は統合バッファ構築時に既にグローバル化されている
    float4 p1Screen = _ScreenPositionBuffer[seg.v1];
    float4 p2Screen = _ScreenPositionBuffer[seg.v2];
    
    // どちらかの頂点が無効なら無限大
    if (p1Screen.w < 0.5 || p2Screen.w < 0.5)
    {
        _LineHitDistanceBuffer[globalLineIdx] = 1e10;
        _LineHitDepthBuffer[globalLineIdx] = 1e10;
        return;
    }
    
    float2 p1 = p1Screen.xy;
    float2 p2 = p2Screen.xy;
    float2 pt = _MousePosition;
    
    // 点と線分の最短距離
    float2 segDir = p2 - p1;
    float lenSq = dot(segDir, segDir);
    
    if (lenSq < 0.000001)
    {
        // 線分が点に縮退
        _LineHitDistanceBuffer[globalLineIdx] = length(pt - p1);
        _LineHitDepthBuffer[globalLineIdx] = p1Screen.z;
        return;
    }
    
    float t = clamp(dot(pt - p1, segDir) / lenSq, 0.0, 1.0);
    float2 projection = p1 + t * segDir;
    _LineHitDistanceBuffer[globalLineIdx] = length(pt - projection);
    
    // 深度を補間して出力
    _LineHitDepthBuffer[globalLineIdx] = lerp(p1Screen.z, p2Screen.z, t);
}

/// <summary>
/// 面ヒットテスト：マウス座標が面内にあるかを判定
/// 多角形の内外判定（レイキャスト法）
/// ヒット時は面の平均深度も出力
/// 
/// 【注意】_MousePosition は adjustedRect 座標系で渡すこと
/// </summary>
[numthreads(64, 1, 1)]
void ComputeFaceHitTest(uint3 id : SV_DispatchThreadID)
{
    uint faceIndex = id.x;
    if (faceIndex >= _FaceCount) return;
    
    // オフセットを適用
    uint globalFaceIdx = _FaceOffset + faceIndex;
    
    float visibility = _FaceVisibilityBuffer[globalFaceIdx];
    
    // 不可視の面はヒットなし
    if (visibility < 0.5)
    {
        _FaceHitBuffer[globalFaceIdx] = 0.0;
        _FaceHitDepthBuffer[globalFaceIdx] = 1e10;  // 無限遠
        return;
    }
    
    int vertexCount = asint(_FaceVertexCountBuffer.Load(globalFaceIdx * 4));
    int offset = asint(_FaceVertexOffsetBuffer.Load(globalFaceIdx * 4));
    
    if (vertexCount < 3)
    {
        _FaceHitBuffer[globalFaceIdx] = 0.0;
        _FaceHitDepthBuffer[globalFaceIdx] = 1e10;
        return;
    }
    
    // 多角形の頂点を取得（深度も取得）
    float2 polygon[16];
    float depths[16];
    float totalDepth = 0;
    bool allValid = true;
    for (int i = 0; i < vertexCount && i < 16; i++)
    {
        int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + i) * 4));
        // vIdxは統合バッファ構築時に既にグローバル化されている
        float4 screenPos = _ScreenPositionBuffer[vIdx];
        if (screenPos.w < 0.5) { allValid = false; break; }
        polygon[i] = screenPos.xy;
        depths[i] = screenPos.z;
        totalDepth += screenPos.z;
    }
    
    if (!allValid)
    {
        _FaceHitBuffer[globalFaceIdx] = 0.0;
        _FaceHitDepthBuffer[globalFaceIdx] = 1e10;
        return;
    }
    
    // レイキャスト法で内外判定
    float2 pt = _MousePosition;
    int crossings = 0;
    
    for (int j = 0; j < vertexCount; j++)
    {
        int next = (j + 1) % vertexCount;
        float2 v0 = polygon[j];
        float2 v1 = polygon[next];
        
        // 右方向へのレイが辺と交差するか
        if ((v0.y <= pt.y && v1.y > pt.y) || (v1.y <= pt.y && v0.y > pt.y))
        {
            float vt = (pt.y - v0.y) / (v1.y - v0.y);
            float xIntersect = v0.x + vt * (v1.x - v0.x);
            if (pt.x < xIntersect)
            {
                crossings++;
            }
        }
    }
    
    // 奇数回交差 = 内部
    bool isHit = (crossings & 1) != 0;
    _FaceHitBuffer[globalFaceIdx] = isHit ? 1.0 : 0.0;
    
    // 深度を出力（ヒット時は平均深度、非ヒット時は無限遠）
    _FaceHitDepthBuffer[globalFaceIdx] = isHit ? (totalDepth / vertexCount) : 1e10;
}
